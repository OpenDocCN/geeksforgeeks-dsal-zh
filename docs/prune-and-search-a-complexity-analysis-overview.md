# 修剪和搜索|复杂性分析概述

> 原文:[https://www . geeksforgeeks . org/修剪和搜索-复杂性-分析-概述/](https://www.geeksforgeeks.org/prune-and-search-a-complexity-analysis-overview/)

**修剪**这个词的意思是通过去掉不必要的东西来减少一些东西。因此，**剪枝搜索**是解决各种优化问题的优秀算法范例。这种方法最早是由**尼姆罗德·梅吉多在 **1983** 中提出的。这种方法总是由几次迭代组成。在每次迭代中，它会丢弃一小部分输入数据，比如 f，然后对剩余数据递归调用相同的算法来解决问题。**

这种方法的主要思想是*通过修剪一部分输入元素来减少搜索空间，并在剩余的有效输入元素*上递归。经过一些迭代后，输入数据的大小将变得如此之小，以至于可以在恒定的时间 c '内用蛮力方法求解。

**此类算法的时间复杂度分析:**
让每次迭代所需的时间为 **O(n^k)** 其中-

```
n = size of input data 
k is some constant. 
```

让 **f** =每次迭代中移除的数据部分。递归地，上面的方法可以写成-

> T(n) = T((1-f)n) + O(n^k)
> 我们有，
> T(n) < = T((1-f)n) + c*n^k 为非常大的值 n .
> <= t((1-f)^2 * n)+c*n^k +c*((1-f)^k)*n^k
> 。
> 。
> <= c '+c*n^k+c*((1-f)^k)n^k+c*((1-f)^2k)n^k+…..+c*((1-f)^pk)n^k
> = c '+c*n^k(1+(1-f)^k+(1-f)^2k+…..+ (1-f)^pk).
> 由于(1-f) < 1，由于 n 趋向于非常大的数字
> 因此，T(n) = O(n^k).

结果表明，整个过程的时间复杂度与每次迭代中剪枝搜索的时间复杂度处于同一数量级。这种方法可以用来分析许多已知问题的算法，如二分搜索法，从一个未排序的数组中找到第 k 个最大/最小元素(选择问题)，1-中心问题(最小封闭圆)，求解二元线性规划，等等。

**示例:**

**1。二分搜索法:**
正如我们所知，这种技术应用于排序的数据列表，用于在给定的列表中搜索特定值的索引(比如说“ **val** ”)。为此，我们转到中间元素，并将其与 **val** 进行比较。如果中间元素等于**值**，那么我们返回这个中间元素。否则，我们将删除一半的数据，并对剩余的元素使用相同的技术。具体实施见[本](https://www.geeksforgeeks.org/binary-search/)。
**时间复杂度分析:**
在每一步中，由于是只比较 **val** 与中间元素，所以这一步的复杂度会是 **O(1)** 假设是 **c** (任意常量)。并且去掉了一半的列表，所以 **T(n) = T(n/2) + O(1)如果 n > =2** 否则 **T(n) = O(1) = c** 。

> 简单来说，
> T(n)= T(n/2)+c
> = T(n/4)+c+c
> = T(n/8)+c+c+c
> …..
> = T(1) + c + … + c + c
> = k 乘以 c，其中 k 为常数。
> 由于在每次迭代中丢弃了一半的输入，因此在最坏的情况下，k 的值最多为 log(n)。因此，二分搜索法的最坏情况复杂度将是
> **T(n) = O(log(n))** 。

**2。选择问题:**
给定一个无序的 **n** 元素列表，任务是从列表中找到第 k 个最小的元素。第一个非常基本的方法是按升序对给定的列表进行排序，并直接在 Kth 索引处选取值。所以排序一般会用 **O(n*log(n))** 时间和 **O(1)** 来检索 Kth 指标值。因此，总的来说 **T(n) = O(n*log(n))** 为这种方法。
第二种方法是使用快速选择方法，即剪枝搜索技术。这种剪枝搜索选择算法的基本思想是确定一个不包含 Kth 元素的部分，并在下一次迭代中丢弃该部分元素。我们知道，为了有一个 **O(n)** 算法，我们必须有一个能够在每次迭代中修剪掉 **O(n)** 中一小部分元素的方法。让 **P** 成为列表中可以将给定列表分为两部分的元素，比如 **S1** 和 **S2** ，这样 **S1** 包含所有小于或等于 **P** 的元素， **S2** 包含所有大于 **P** 的元素。现在我们可以说

1.  如果 **|S1| == K** ，那么**S1【K】**将是第 K 个最小元素。
2.  如果 **|S1| > K** ，那么 **S1** 中必须存在第 K 个元素。所以丢弃第二部分 **S2** ，用同样的算法在 **S1** 上递归。
3.  否则，Kth 元素必须在 **S2** 中。所以丢弃 **S1** 并在 **S2** 上递归以获得 **S2** 中的第(K-|S1|)个元素。

这里的关键点是如何选择 **P** ，这样无论是修剪 **S1** 还是 **S2** ，我们总能丢弃一部分 S。答案是 **P** 应该是列表 **S** 的[中位数](https://en.wikipedia.org/wiki/Median)。再次，求中位数是这个问题的特例 **K=n/2** 。
但是可以使用以下算法通过其他方式更有效地计算中位数:

1.  将列表分成 **n/5** 个子列表，每个子列表最多包含 5 个元素。
2.  现在我们可以对每个子列表进行排序，并在恒定时间内找到它们的中间值。
3.  再次递归查找所有中位数的中位数，直到大小变为最多 5。所获得的中间值将是快速选择算法中使用的完美轴心。[注意[插入排序](https://contribute.geeksforgeeks.org/improve/insertion-sort-5/)将是排序 5 号较小子列表的更好选择。]

**为什么只有 5 个？**
将列表分成 5 份假设最坏的情况是 70-30 份。至少一半的中间值大于中间值的中间值，因此一半的 n/5 块至少有 3 个元素给出 3n/10 的分割，这意味着另一个分区在最坏的情况下是 7n/10，即 T(n) = T(n/5) + T(7n/10) + O(n)。既然(n/5 + 7n/10) < 1，那么最坏情况下 T(n) = O(n)。设 P 为中位数，可表示为-

```
|1''1''1''1''1| 1  1  1  1
|2  2  2  2  2| 2  2  2  2
|3__3__3__3_|P|'3''3''3''3|
 4  4  4  4 |4  4  4  4  4| 
 5  5  5  5 |5__5__5__5__5|
```

如图所示， **S** 中至少有四分之一的元素小于或等于 **P** ， **S** 中至少有四分之一的元素大于或等于 **P** 。因此，如果我们以这种方式选择 P，我们总是可以在每次迭代中删除至少四分之一的元素。因此，将 S 拆分为大小为 5 的子列表将是找到中位数的有效方法。现在我们可以把算法表述为-

> **剪枝搜索算法查找第 k 个最小元素**
> **输入:**一组 S n 个元素和 K.
> **输出:**S .
> **中的第 k 个最小元素逼近:**
> 步骤-1:如果|S| < = 5，应用任意蛮力方法。
> 步骤 2:将 S 分成 n/5 个子列表，每个子列表最多包含 5 个元素。
> 第三步:对每个子列表进行排序([插入排序](https://contribute.geeksforgeeks.org/improve/insertion-sort-5/)会更好应用)。
> 第四步:递归寻找每个子列表的中间值。
> 步骤-5:将 S 划分为 S1 和 S2，这样 S1 包含所有小于或等于 P 的元素，S2 包含所有大于 P 的元素
> 步骤-6:现在可以有三种情况作为
> a)如果|S1| == K，那么 S1[k]将是第 K 个最小的元素。
> b)如果|S1| > K，那么 S1 一定存在 Kth 元素。所以丢弃第二部分 s2，用同样的算法在 s1 上递归。
> c)否则 Kth 元素一定在 S2。所以放弃 S1，在 S2 的第(K-|S1|)个元素上递归到 S2。

有关详细代码和实现，请访问[未排序数组中第 K 个最小/最大元素|集合 3(最坏情况线性时间)](https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array-set-3-worst-case-linear-time/)

**复杂性分析:**由于每个子列表包含 5 个元素，因此对它们进行排序将花费恒定的时间。因此，步骤 2、3 和 5 可以在 O(n)时间内完成，步骤 4 需要 T(n/5)时间，因为我们正在递归地使用相同的算法来寻找 n/5 个中间值的中值。因为我们在每次迭代中至少修剪 n/4 个元素，所以在最坏的情况下，每次迭代后会剩下 3n/4 个元素。因此，T(n) = T(3n/4) + T(n/5) + O(n)。

> 设 T(n) = a0 + a1*n + a2*(n^2) + …。其中 a1！= 0.
> 我们有
> t(3n/4)= A0+(3/4)a1 * n+(9/16)a2*(n^2)+…。
> t(n/5)= A0+(1/5)a1 * n+(1/25)a2*(n^2)+…。
> t((3n/4)+(n/5))= t(19n/20)= A0+(19/20)a1 * n+(361/400)a2*(n^2)+…。
> 因此，T(3n/4)+T(n/5)<= A0+T(19n/20)。
> 因此，
> T(n)= T(3n/4)+T(n/5)+O(n)
> <= T(19n/20)+cn。
> 将最初得到的一般情况下的公式应用于这个不等式，
> 我们将得到 T(n) = O(n)。

因此，我们有一个最坏情况的线性时间算法来解决基于剪枝搜索技术的选择问题。同样，我们可以应用这些类型的策略来解决带有两个变量的[线性规划](https://en.wikipedia.org/wiki/Linear_programming)和[最小封闭圆](https://en.wikipedia.org/wiki/1-center_problem)问题。