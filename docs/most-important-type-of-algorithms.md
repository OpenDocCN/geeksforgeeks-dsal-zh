# 最重要的算法类型

> 原文:[https://www . geesforgeks . org/最重要的算法类型/](https://www.geeksforgeeks.org/most-important-type-of-algorithms/)

**<u>算法:</u>**
算法是解决问题的循序渐进的过程。一个好的算法应该在时间和空间上进行优化。不同类型的问题需要不同类型的算法技术以最优化的方式来解决。有许多类型的算法，但最重要的和你必须知道的基本算法将在本文中讨论。

**<u>蛮力算法:</u>**
这是最基本也是最简单的一类算法。蛮力算法是解决问题的直接方法，即我们看到问题时想到的第一种方法。从技术上讲，这就像迭代所有可能的方法来解决这个问题。

**例如:**如果有锁的 **4 位** PIN。要从 **0-9** 中选择的数字，然后蛮力会逐个尝试所有可能的组合，如 **0001** 、 **0002** 、 **0003** 、 **0004** 等等，直到我们得到正确的个人识别码。最坏的情况下**需要 1 万次尝试**才能找到合适的组合。

**<u>递归算法:</u>**
这类算法基于[递归](https://www.geeksforgeeks.org/recursion/)。在递归中，通过将问题分解成相同类型的子问题，并一次又一次地调用自身来解决问题，直到问题在基本条件的帮助下得到解决。

用递归算法解决的一些常见问题有[一个数的阶乘](https://www.geeksforgeeks.org/program-for-factorial-of-a-number/)、[斐波那契数列](https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/)、[汉诺塔](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/)、[图的 DFS](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)等。

**<u>[分而治之算法](https://www.geeksforgeeks.org/divide-and-conquer-introduction/) :</u>**
在分而治之算法中，思路是把问题分成两个部分来解决，第一部分把问题分成同类型的子问题。第二部分是独立解决较小的问题，然后将组合结果相加，得出问题的最终答案。

使用除法和征服算法解决的一些常见问题有[二分搜索法](https://www.geeksforgeeks.org/binary-search/)、[合并排序](https://www.geeksforgeeks.org/merge-sort/)、[快速排序、](https://www.geeksforgeeks.org/quick-sort/)T6】斯特拉森矩阵乘法等。

**<u>[动态规划算法](https://www.geeksforgeeks.org/dynamic-programming/) :</u>**
这种类型的算法也被称为[记忆技术](https://www.geeksforgeeks.org/memoization-1d-2d-and-3d/)，因为在这种情况下，想法是存储先前计算的结果，以避免反复计算。在动态规划中，将复杂的问题分成更小的[重叠子问题](https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/)，并存储结果以备将来使用。

使用动态规划算法[背包问题](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)、[加权作业调度](https://www.geeksforgeeks.org/weighted-job-scheduling/)、[弗洛伊德沃肖尔算法](https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/)、[迪克斯特拉最短路径算法](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)等可以解决以下问题。

**<u>[贪婪算法](https://www.geeksforgeeks.org/greedy-algorithms/) :</u>**
在贪婪算法中，解是一部分一部分构建的。选择下一个零件的决定是基于它能带来立竿见影的好处。它从不考虑以前做出的选择。

通过贪婪算法可以解决的常见问题有 [Prim 算法](https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/)、 [Kruskal 算法](https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/)、[霍夫曼编码](https://www.geeksforgeeks.org/huffman-coding-greedy-algo-3/)、等。

**<u>[回溯算法](https://www.geeksforgeeks.org/backtracking-algorithms/) :</u>**
在回溯算法中，问题是以增量方式解决的，也就是说，它是一种递归解决问题的算法技术，试图以增量方式构建一个解决方案，一次一个，删除那些在任何时间点都不能满足问题约束的解决方案。

通过回溯算法可以解决的一些常见问题有[哈密顿圈](https://www.geeksforgeeks.org/hamiltonian-cycle-backtracking-6/)、[M-着色问题](https://www.geeksforgeeks.org/m-coloring-problem-backtracking-5/)、 [N 皇后问题](https://www.geeksforgeeks.org/n-queen-problem-backtracking-3/)、[迷宫鼠问题](https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/)等。