# 何时使用各种排序算法|设置 2

> 原文:[https://www . geesforgeks . org/何时使用各种排序算法-set-2/](https://www.geeksforgeeks.org/when-to-use-each-sorting-algorithms-set-2/)

[排序](https://www.geeksforgeeks.org/sorting-algorithms/)是将一组数据按照特定的顺序排列的过程，可以是数字(升序、降序)也可以是字典顺序(字母顺序)。

**为什么需要排序？**

当需要高度优化[搜索算法](https://www.geeksforgeeks.org/searching-algorithms/)时，排序是非常必要的。例如，让我们假设搜索某个元素的两种情况。
**案例 1:** 从一组随机元素中搜索一个元素。(未排序)
**情况 2:** 从有序元素集中搜索元素。(已排序)
很明显，在案例 2 中搜索一个元素会更容易更快，因为元素是以前排序过的，所以搜索花费的时间会更少。

**何时使用各种排序算法？**

对于数据排序，有不同的算法可以用来对数据进行排序，但出现的主要问题是，如何选择合适的算法来实现尽可能高的效率？
在选择排序算法之前，有几个因素需要考虑:

*   **数据大小:**存在的元素或数据总数可以大也可以小。
*   **数据状态:**数据是完全随机、部分排序还是几乎排序。
*   [**时空复杂度**](https://www.geeksforgeeks.org/understanding-time-complexity-simple-examples/) **:** 我们需要投入的时空量。

让我们来看看各种排序算法:

[**【堆排序】**](https://www.geeksforgeeks.org/heap-sort/) **:** 它从可用元素构建二进制堆数据结构，然后使用堆进行排序。这是一种基于比较的(就地)排序算法，没有二次最坏情况运行时间。Heapsort 可以按照以下限制使用:

*   这个算法最好的一点是它不需要任何额外的内存，所以如果对没有额外空间要求的算法有要求，那么可以进行堆排序。
*   它表现出一致的性能。因此，它在最好、一般和最坏的情况下都表现良好。由于其保证的性能，它被用在具有关键响应时间的系统中。
*   堆运动特别适合对一个巨大的元素列表进行排序。

**时间复杂度:**

*   **最佳情况:** O(N*log N)
*   **平均情况:**O(N *对数 N)
*   **最差情况:** O(N*log N)

**空间复杂度:** O(1)

[**贝壳排序**](https://www.geeksforgeeks.org/shellsort/)【T4:是原地比较排序。该算法避免了大的移位，如在插入排序的情况下，如果较小的值在最右边并且必须移动到最左边。与插入排序或冒泡排序相比，壳排序更有效，并且在以下情况下使用

*   较小的值元素位于数组/列表的末尾。
*   当有一个大规模的数组/列表，并且接近的元素相距很远时，通过这种算法，我们可以减少这些元素之间的距离，因此在这种情况下需要更少的交换。
*   当递归超过限制时，可以使用该算法。

**时间复杂度:**

*   **最佳情况:** O(N*log N)
*   **平均情况:**取决于间隙顺序
*   **最差情况:** O(N*log <sup>2</sup> N)

**空间复杂度:** O(1)

[**【基数排序】**](https://www.geeksforgeeks.org/radix-sort/) **:是一种非比较排序算法。它通过根据基数创建元素并将元素分配到桶中来避免比较。它的线性时间复杂度优于比较排序算法的 O(N*log N)。基数排序可以按照下面的约束使用-**

*   当给定列表中元素的重复不多，但元素的长度在同一范围内时，使用基数排序是有益的。
*   基数排序广泛用于可以按字典顺序排序的数据。
*   它也适用于字符串的稳定排序。

**时间复杂度:**

*   **最佳情况:** O(N*K)
*   **平均情况:** O(N*K)
*   **最差情况:** O(N*K)

**空间复杂度:** O(N + K)

[**【桶排序】**](https://www.geeksforgeeks.org/bucket-sort-2/) **:** 桶排序的工作原理是将数组的元素分配到多个桶中。然后，每个存储桶被单独排序，并被追加到一个数组中。这是一个相当稳定的算法，因为一旦元素被分配到桶中，每个桶都可以独立于其他桶进行处理。桶排序可以按照以下约束使用-

*   它用于加快排序过程，因为将项目放入桶中，然后以较小的数量进行排序的过程比任何其他线性排序算法(如冒泡排序)都要快得多。
*   当输入在一个范围内均匀分布时，它非常有用。
*   桶排序的另一个优点是，它可以用作外部排序算法。

**时间复杂度:**

**最佳情况:**O(N+K)
T3】平均情况:O(N)
T6】最差情况: O(N <sup>2</sup>

**空间复杂度:** O(N*K)

[**【计数排序】**](https://www.geeksforgeeks.org/counting-sort/) **:** 该算法通过计数数组中每个唯一元素的出现次数，对数组中的元素进行排序。它通常用作另一种排序算法(如基数排序)中的子程序，可以更有效地处理较大的键。这不是一种比较。计数排序可以按照以下限制使用:

*   当不同键(小数字)之间的差异不是很大时，它很有用。
*   当列表/数组包含有限范围的数字并且重复很多时，在这种情况下，计数排序会有所帮助。
*   它是一种稳定的排序算法。

**时间复杂度:**

*   **最佳情况:** O(N + K)
*   **平均情况:** O(N + K)
*   **最差情况:** O(N + K)

**空间复杂度:** O(N + K)