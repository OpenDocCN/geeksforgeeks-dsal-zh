# 不同分选技术分析

> 原文:[https://www . geeksforgeeks . org/不同分类技术分析/](https://www.geeksforgeeks.org/analysis-of-different-sorting-techniques/)

在本文中，我们将讨论不同排序技术的重要属性，包括它们的复杂性、稳定性和内存限制。在理解本文之前，您应该了解不同排序技术的基础知识(参见:[排序技术](https://www.geeksforgeeks.org/fundamentals-of-algorithms/#SearchingandSorting))。

**时间复杂度分析–**
我们已经讨论了不同排序技术在可能场景下的最佳、平均和最坏情况复杂度。

**基于比较的排序–**
在基于比较的排序中，将数组的元素相互比较以找到排序后的数组。

*   **冒泡排序和插入排序–**
    平均和最坏情况时间复杂度:n^2
    最佳情况时间复杂度:数组已经排序时 n。
    最差情况:数组反向排序时。

*   **选择排序–**
    最佳、平均和最坏情况时间复杂度:独立于数据分布的 n^2。

*   **合并排序–**
    最佳、平均和最坏情况时间复杂度:nlogn，与数据分布无关。

*   **堆排序–**
    最佳、平均和最坏情况时间复杂度:nlogn，与数据分布无关。

*   **快速排序–**
    这是一个具有递归关系的分治法:

```
 T(n) = T(k) + T(n-k-1) + cn
```

*   最坏的情况:当数组被排序或反向排序时，分区算法将数组分成两个子数组，其中包含 0 和 n-1 个元素。因此，

```
T(n) = T(0) + T(n-1) + cn
Solving this we get, T(n) = O(n^2)
```

*   最佳情况和平均情况:平均而言，分区算法将阵列分成大小相等的两个子阵列。因此，

```
T(n) = 2T(n/2) + cn
Solving this we get, T(n) = O(nlogn)

```

**基于非比较的排序–**
在基于非比较的排序中，数组的元素不会相互比较以找到排序后的数组。

*   **基数排序–**
    最佳、平均和最坏情况时间复杂度:nk 其中 k 是数组元素中的最大位数。

*   **计数排序–**
    最佳、平均和最坏情况时间复杂度:n+k，其中 k 为计数数组的大小。

*   **桶排序–**
    最佳平均时间复杂度:n+k 其中 k 为桶数。
    最坏情况时间复杂度:n^2 如果所有元素都属于同一个桶。

**就地/输出技术–**
如果排序技术不使用任何额外的内存来对数组进行排序，则该技术是就地的。
在讨论的基于比较的技术中，只有合并排序是输出技术，因为它需要额外的阵列来合并排序的子阵列。
在讨论的非基于比较的技术中，所有都是输出技术。计数排序使用计数数组，桶排序使用哈希表对数组进行排序。

**在线/离线技术–**
如果排序技术可以在程序进行期间接受新数据，即开始排序操作不需要完整的数据，则该技术被视为在线。
在讨论的基于比较的技术中，只有插入排序有资格这样做，因为它使用的底层算法，即它从左到右处理数组(不仅仅是元素)，如果新元素添加到右边，它不会影响正在进行的操作。

**稳定/不稳定技术–**
一种排序技术，如果不改变相同值元素的顺序，就是稳定的。
在基于比较的技术中，冒泡排序、插入排序和合并排序是稳定的技术。选择排序不稳定，因为它可能会改变具有相同值的元素的顺序。例如，考虑数组 4，4，1，3。

在第一次迭代中，找到的最小元素是 1，并在第 0 个位置与 4 交换。因此，相对于第一位置的 4，4 的顺序将改变。同样，快速排序和堆排序也不稳定。

在基于非比较的技术中，计数排序和桶排序是稳定的排序技术，而基数排序的稳定性取决于用于排序的底层算法。

**分拣技术分析:**

*   当数组几乎被排序时，可以优先选择插入排序。
*   当输入的顺序未知时，合并排序是优选的，因为它具有 nlogn 的最坏情况时间复杂度，并且它也是稳定的。
*   当数组被排序时，插入和冒泡排序给出了 n 的复杂度，而快速排序给出了 n^2.的复杂度

**Que–1。**当输入数组的所有元素都相同时，哪种排序算法耗时最少？考虑排序算法的典型实现。
(一)插入排序
(二)堆排序
(三)合并排序
(四)选择排序

**解决方案:**如前所述，当输入数组已经排序时，插入排序的复杂度为 n。

**Que–2。**考虑快速排序算法。假设有一个查找透视元素的过程，该过程将列表分成两个子列表，每个子列表至少包含五分之一的元素。设 T(n)为排序 n 个元素所需的比较次数。然后，(GATE-CS-2012)

(A) T(n) <= 2T(n/5) + n

(二)T(n) <= T(n/5) + T(4n/5) + n

(C) T(n) <= 2T(4n/5) + n

(D) T(n) <= 2T(n/2) + n

**解:**快速排序的复杂度可以写成:

```
T(n) = T(k) + T(n-k-1) + cn
```

如所述，一个列表包含全部元素的 1/5。因此，另一个列表将有总元素的 4/5。把价值观，我们得到:

T(n) = T(n/5) + T(4n/5) + cn，与选项(B)匹配。

### 时间和空间复杂性对照表:

<figure class="table">

| 分类算法 | 时间复杂性 | 空间复杂性 |
| --- | --- | --- |
|   | 最佳案例 | 平均案例 | 最坏情况 | 最坏情况 |
| --- | --- | --- | --- | --- |
| **气泡排序** | **ω(n)** | **θ(n<sup>【2】</sup>)** | **O(N <sup>2</sup> )** | **O(1)** |
| **选择排序** | **ω(n<sup>【2】</sup>)** | **θ(n<sup>【2】</sup>)** | **O(N <sup>2</sup> )** | **O(1)** |
| **插入输出** | **ω(n)** | **θ(n<sup>【2】</sup>)** | **O(N <sup>2</sup> )** | **O(1)** |
| **合并排序** | 【t0(n 个日志 N) | **θ(n 个记录 N) 【T1** | **O(N 对数 N)** | **O(N)** |
| **堆排序** | 【t0(n 个日志 N) | **θ(n 个记录 N) 【T1** | **O(N 对数 N)** | **O(1)** |
| **快速排序** | 【t0(n 个日志 N) | **θ(n 个记录 N) 【T1** | **O(N <sup>2</sup> )** | **O(对数 N)** |
| **基数排序** | **ω(n k)** | **θ(n k)** | **O(N k)** | **O(N + k)** |
| **计数排序** | **ω(n+k)** | **θ(n+k)** | **O(N + k)** | **O(k)** |
| **桶排序** | **ω(n+k)** | **θ(n+k)** | **O(N <sup>2</sup> )** | **O(N)** |

</figure>